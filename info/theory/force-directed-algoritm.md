# force-directed algorithm

Алгоритм, который рассчитывает положение вершин графа, моделируя ребра как силы притяжения и отталкивания, называется силовым алгоритмом визуализации графов (force-directed algorithm). Вершины считаются заряженными частицами, а ребра — пружинами между ними, причем действуют силы притяжения и отталкивания, стремящиеся расположить граф в пространстве с минимальной энергией и эстетично. Этот алгоритм подходит для любых графов и не требует специальных знаний о свойствах графа, таких как планарность. Его идея — найти такое расположение вершин, чтобы ребра имели примерно одинаковую длину, а пересечения были минимальны.

Основные свойства силового алгоритма:
- Симметричное и эстетичное расположение вершин
- Связанные вершины находятся рядом, несвязанные — дальше
- Минимизация энергии системы сил (равновесное состояние)
- Подходит для визуализации графов различной структуры и размера, но большой граф требует оптимизаций из-за вычислительной нагрузки

Этот класс алгоритмов с 1984 года активно используется и модифицируется для различных задач визуализации графов.[1][2][4]

[1](https://oktmo.ru/stati/32296-silovye-algoritmy-vizualizacii-grafov.html)
[2](https://pco.iis.nsk.su/wega/index.php/%D0%A1%D0%B8%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B)
[3](https://www.mais-journal.ru/jour/article/download/1025/740)
[4](https://www.kubsu.ru/sites/default/files/users/8755/portfolio/algoritmy_vizualizacii_dinamicheskih_grafov_dlya_analiza_slozhnyh_setey.docx)
[5](http://sitito.cs.msu.ru/index.php/SITITO/article/view/882)
[6](https://habr.com/ru/companies/ods/articles/464715/)
[7](https://sv-journal.org/2018-1/02/?lang=ru)
[8](https://repo.ssau.ru/handle/Vypusknye-kvalifikacionnye-raboty/Issledovanie-effektivnosti-silovyh-algoritmov-vizualizacii-neplanarnyh-grafov-vyp-kvalifikac-rabota-po-spec-Informatika-i-vychislitelnaya-tehnika-73561)
[9](https://www.hse.ru/edu/vkr/926349412)

# Реализация

Чтобы написать силовой алгоритм визуализации графов, нужно реализовать следующие основные шаги:

1. Инициализация позиций вершин случайным образом или с помощью второго метода.
2. Для каждой итерации вычислить силы, действующие на каждую вершину:
   - Сила отталкивания между всеми парами вершин (как заряды одинакового знака).
   - Сила притяжения вдоль рёбер (как пружина, стремящаяся вернуть расстояние к заданной длине).
3. Обновить позиции вершин, применяя вычисленные силы с некоторым шагом перемещения (learning rate).
4. Повторять итерации до тех пор, пока система не стабилизируется (силы становятся малы) или достигается максимальное число шагов.

### Общая формула сил:
- Сила отталкивания между вершинами  u  и  v :

$$
F_{\text{repel}}(d) = \frac{k^2}{d}
$$

- Сила притяжения вдоль ребра (u, v) :

$$
F_{\text{attract}}(d) = \frac{d^2}{k}
$$


где  d  — текущее расстояние между вершинами, а  k  — оптимальная длина ребра, обычно рассчитывается как $$ k = C \sqrt{\frac{\text{площадь}}{|\text{вершины}|}} $$ с константой  C .

### Пример псевдокода

```
инициализировать позиции вершин случайно
рассчитать k = C * sqrt(площадь / количество_вершин)

пока не достигнута сходимость:
    для каждой вершины v:
        сумма_сил = (0,0)
        для каждой другой вершины u:
            если u != v:
                вычислить силу отталкивания и добавить к сумме_сил
        для каждого соседа u вершины v:
            вычислить силу притяжения и добавить к сумме_сил
        обновить позицию v с учетом суммы сил и коэффициента шага
    уменьшить шаг перемещения (чтобы стабилизировать расчет)
```

Если нужно, могу помочь с примером на конкретном языке программирования, например Python или Golang. Этот подход можно расширять с оптимизациями, например использованием квадродерева для ускорения расчета отталкивающих сил.

Хотите пример кода на каком-то языке?









